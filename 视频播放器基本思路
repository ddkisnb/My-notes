在Qt中，有多种方式可以实现播放器功能。
比如：使用QMediaPlayer类：QMediaPlayer是Qt提供的一个高级多媒体播放器框架，支持多种音频和视频格式。通过使用QMediaPlayer，可以轻松地播放、暂停、停止和切换媒体文件。
此外，QMediaPlayer还提供了许多其他有用的功能，如获取媒体信息、设置音量、亮度等。
使用第三方库：除了QMediaPlayer之外，还有许多第三方库可用于在Qt中实现播放器功能。
这些库可提供更多的功能和更好的性能，常见的第三方库包括FFmpeg、GStreamer等。
自定义播放器：如果需要更高级的功能或者想要实现自己的播放器逻辑，可以考虑自定义播放器。
这通常涉及到使用Qt的多媒体框架（如QMediaPlayer、QMediaPlaylist等）以及一些其他的Qt组件（如QWidget、QSlider等）来创建一个自定义的播放器界面和功能。
今天咱们就用Qt+FFmpeg，开发一个视频播放器。

Part1为什么选Qt+FFmpeg？
Qt自带的QMediaPlayer确实能播视频，但它像封装好的“黑箱”——你点播放它就播，点暂停就暂停，可解码流程、帧处理这些核心操作全藏在内部，学不到东西。
而FFmpeg是开源界的“解码全能王”，几乎能处理所有主流视频格式（MP4、MOV、AVI…），配合Qt的界面能力，既能练技术，又能完全掌控播放器逻辑。
不过要注意：FFmpeg本身不直接渲染界面，得靠Qt的QWidget或QPainter来“画”解码后的画面；音频部分更麻烦，得借SDL2（简单音频库）来帮忙——这三者配合，就是咱们今天的“铁三角”。

Part2环境准备•Qt：选5.12.12（稳定版，文档全，社区问题多易解决）；
•编译器：MSVC2017 64位（FFmpeg最新版对MinGW支持一般，MSVC更稳）；
•FFmpeg：6.1.1（别用太旧的，新API更规范，比如avformat_open_input的参数调整）；
•SDL2：2.0.10+（只用来播音频，轻量且跨平台）。装环境时记得：FFmpeg要编译成动态库（.dll/.so），并把头文件和库路径加到Qt工程里；SDL2同理，编译时链接它的库。

Part3核心功能功能点技术拆解支持多格式视频FFmpeg的avformat_open_input能自动识别容器格式（MP4的ISOBMFF、AVI的RIFF），配合解复用器（demuxer）拆分音视频流。
匀速播放通过控制解码时间戳（PTS）和播放时钟同步，比如用QTimer按帧间隔（如1/30秒）触发解码。自适应窗口缩放用QPainter的drawImage配合scaled方法，
根据窗口大小动态调整图像分辨率，保持宽高比。实时控制（暂停/继续）用标志位（如isPaused）控制解码线程的循环，暂停时停止取包和解码，继续时从当前帧继续。
模块化低耦合解耦成三个独立模块：解复用（拆分包）、视频解码（转RGB）、UI渲染（画画面），用信号槽传数据。

Part4实现思路视频播放是个“多任务协同”的过程：既要解视频，又要解音频，还要渲染画面，单线程肯定卡成PPT。所以咱们用三条线程+两个队列来分工：

1. 线程1：解复用（音视频分离）这一步像“拆快递”——把输入的视频文件（如MP4）拆成一个个“小包裹”（AVPacket），再按类型分到两个“快递柜”（视频队列、音频队列）。
•关键操作：用FFmpeg的av_read_frame循环读取包，判断是视频流（codecpar->codec_type == AVMEDIA_TYPE_VIDEO）还是音频流，然后塞进对应的队列。
•注意：队列要加锁（QMutex），避免多线程抢数据导致崩溃；队列长度设上限（比如100个包），防止内存爆炸。
2. 线程2：视频解码（从包到帧）拿到视频队列里的包（AVPacket），
下一步是“翻译”——把压缩的视频数据（H.264、H.265等）解成原始图像帧（AVFrame）。•关键操作：•用avcodec_send_packet发送包到解码器；•用avcodec_receive_frame接收解码后的帧；
•转换像素格式（比如从YUV420P转成RGB24），因为Qt的QPainter只认识RGB。这里用sws_scale（FFmpeg的缩放转换函数）搞定。
输出：解码后的RGB图像（QImage或QPixmap），通过信号槽发给UI线程渲染。
3. 线程3：音频解码（SDL帮忙）音频处理比视频简单些，但Qt没自带好用的音频播放接口，所以借SDL2的力。
SDL的音频模块支持回调模式：•关键操作：•初始化SDL的音频设备（SDL_OpenAudioDevice）；
•设置回调函数，从音频队列里取包（AVPacket），解码（avcodec_send_packet/avcodec_receive_frame），转成PCM数据（原始声音波形）；
•SDL会把PCM数据直接输出到声卡，完成播放。

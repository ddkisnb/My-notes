在C++中，手动管理内存经常容易出错，尤其是容易造成内存泄漏或或者野指针的出现
所以引入了智能指针来自动管理资源内存，智能指针是一个模板类，用来管理动态分配的对象，负责自动释放动态分配的对象

第一个是auto，是最早C++98引入的智能指针，已经被淘汰了，当拷贝/赋值时，会转移资源，这就导致原来的指针被置空，会引出一系列的后续问题。
违背了“拷贝不修改原对象原则”

第二个是unique独占式的智能指针，一个对象只能被一个unique管理，他禁止拷贝，他会通过std::move转换成右值引用，转移资源所有权，特别适合做函数内部的资源管理等资源不共享的场景；
（用法也很简单std::make_unique<T>创建）
底层实现：相比于auto删除了构造函数和拷贝赋值运算符

第三个是share，采用引用计数的方式来管理资源，所以说多个share可以指向同一个对象，每次拷贝，引用计数+1，析构时-1，当引用计数为0时释放资源
特别是资源需要被多个模块共享的场景，如：一些缓存，异步处理
使用时需要注意，引用计数需要加锁保证线程安全；
就是可能产生循环引用，两个对象互相使用一个share指向对方，资源永不释放
（引用计数本身的增减是原子操作，因此多个线程可以安全地拷贝和销毁 shared_ptr。但资源本身的读写不是线程安全的！）
最后一个weak，是专门用来解决share循环引用的问题。他是对share的弱引用
不会增加计数，也不参与资源管理，只引用，不计数，会去检测对象是否已经被释放，从而避免访问非法内存
当一块内存被share和weak同时引用，当share析构，weak不会影响内存释放
但是使用前需要检查weak是否是空指针

左值：有名字，可取地址
int a=10; //a是左值

右值是临时的，没有名字
int b=5+6;   //5+6是右值
int c=100;    //100是右值




1.左值引用   T&  ，
只能绑定有名字，可取地址的左值

2.右值引用  T&&   绑定到临时变量上，没有名字的值
int &&r=100;
r=50;

作用：
1.移动语义， 延长右值生命周期 
2.避免不必要的拷贝
void  setValue (std::string &&s){

value =std::move(s);
}
3.支持高性能容器操作 std:: vector


4. 延长右值生命周期 
移动构造
void bar(int  &&x){
cout<<“ 右值引用”<<endl;
}
bar(10);    //ok,   10是右值
int b=5;
bar( std::move(b) );   强行把b转为右值引用

实际用途：移动构造
直接偷走资源
public:

   MyClass(MyClass  &&other){


}


在C++变量中，变量分为左值和右值，左值就是等号左边的值，自己定义的，有名字的变量，
右值就是等号右边的值，它是一个临时变量  int a=10;       10就是右值

以前传递对象只能通过拷贝构造函数，这不仅效率低下，还浪费大量资源。
使用 std::move 将对象转换为右值引用后，配合移动构造函数，可以实现资源的“转移”而非复制。

实现了移动语义，它避免了不必要的深拷贝，极大提升了效率，通常比传统的拷贝赋值快得多。

缺点：
语义混淆T&&万能引用
移动构造，没处理好，（比如没把指针置空），程序崩了
谨慎用，状态不确定
带来额外的代码复杂度

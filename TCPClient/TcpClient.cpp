#include"TcpClient.h"
#include"../mediator/TcpClientMediator.h"

TcpClient::TcpClient(INetMediator* p):m_handle(nullptr){}
TcpClient::~TcpClient(){}

//接收数据的线程函数（调用接收数据的函数）
unsigned __stdcall TcpClient::recvThread(void* lpVoid) {
	TcpClient* pThis = (TcpClient*)lpVoid;
	pThis->recvData();
	return 1;
}

//初始化网络：加载库、创建套接字、连接服务端、创建一个接收数据的线程
bool TcpClient::initNet() {
	//1、加载库
	WORD version = MAKEWORD(_DEF_VERSION_HIGH, _DEF_VERSION_LOW);
	WSADATA data = {};
	int err = WSAStartup(version, &data);
	if (0 != err) {
		cout << "WSAStartup fail" << endl;
		return false;
	}
	//判断版本号是否正确
	if (_DEF_VERSION_HIGH == HIBYTE(data.wVersion) && _DEF_VERSION_LOW == LOBYTE(data.wVersion)) {
		cout << "WSAStartup success" << endl;
	}
	else {
		cout << "WSAStartup version error" << endl;
		return false;
	}

	//2、创建套接字
	m_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (INVALID_SOCKET == m_sock) {
		cout << "socket error:" << WSAGetLastError() << endl;
		return false;
	}
	else {
		cout << "socket success" << endl;
	}

	//3、连接服务端
	sockaddr_in addrServer;
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(_DEF_TCP_PORT);
	addrServer.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	err = connect(m_sock, (sockaddr*)&addrServer, sizeof(addrServer));
	if (SOCKET_ERROR == err) {
		cout << "connect error" << WSAGetLastError() << endl;
		return false;
	}
	else {
		cout << "connect success" << endl;
	}

	//4、创建一个接收数据的线程
	m_handle = (HANDLE)_beginthreadex(0/*线程安全级别，0是使用默认的安全级别*/,
		0/*线程堆栈大小，0是使用默认堆栈大小1M*/,
		&recvThread/*线程要执行的函数的起始地址*/,
		this/*线程要执行的函数的参数*/,
		0/*线程创建的状态，0是创建以后立刻开始运行，CREATE_SUSPENDED是创建以后挂起*/,
		nullptr/*创建线程以后，操作系统给每个线程分配的线程id*/);
	return true;
}

//发送数据(udp:ip ulong类型，决定发给谁；tcp：socket uint，决定了发给谁；
//unsigned long既能在udp里装ip，又能在tcp里装socket)
bool TcpClient::sendData(char* data, int len, unsigned long to) {
	cout << "TcpClient:" << __func__ << endl;
	//1、校验参数合法性
	if (nullptr == data || len <= 0) {
		cout << "paramater error" << endl;
		return false;
	}

	//2、先发包长度
	int nSendNum = send(m_sock, (char*)&len, sizeof(int), 0);
	if (SOCKET_ERROR == nSendNum) {
		cout << "send error:" << WSAGetLastError() << endl;
		return false;
	}

	//3、再发包内容
	nSendNum = send(m_sock, data, len, 0);
	if (SOCKET_ERROR == nSendNum) {
		cout << "send error:" << WSAGetLastError() << endl;
		return false;
	}

	return true;
}

//接收数据(放在线程里)
void TcpClient::recvData() {
	cout << "TcpClient::" << __func__ << endl;
	//接收数据的长度
	int nRecvNum = 0;
	//保存包的长度
	int nPackLen = 0;
	//记录一个包中累计接收到多少数据
	int nOffset = 0;
	while (m_isRunning) {
		//先接收包长度
		nRecvNum = recv(m_sock, (char*)&nPackLen, sizeof(int), 0);
		if (nRecvNum > 0) {
			//接收包长度成功以后，再接收包内容
			//按照包长度new一个空间
			char* packBuf = new char[nPackLen];
			while (nPackLen > 0) {
				nRecvNum = recv(m_sock, packBuf + nOffset, nPackLen, 0);
				if (nRecvNum > 0) {
					nOffset += nRecvNum;
					nPackLen -= nRecvNum;
				}
				else {
					cout << "recv error2:" << WSAGetLastError() << endl;
					break;
				}
			}
			//一个包的内容接收完成，此时nPackLen = 0,nOffset变成包长度
			//TODO:把接收到的数据传给中介者类
			m_pMediator->transmitData(packBuf, nOffset, m_sock);
			//一个包的数据接收完成后，nOffset清零
			nOffset = 0;
		}
		else {
			cout << "recv error1:" << WSAGetLastError() << endl;
			break;
		}
	}
}

//关闭网络(回收线程资源、关闭套接字、卸载库)
void TcpClient::unInitNet() {
	//1、回收线程资源
	//创建线程时，操作系统给每个线程分配3个资源：句柄、线程ID、内核对象，引用计数器是2
	//想要回收线程资源，就需要让引用计数器变成0：结束线程工作；关闭句柄
	m_isRunning = false;
	if (m_handle) {
		//WaitForSingleObject的返回值如果等于WAIT_TIMEOUT，就说明等待的线程在等待时间结束后，还在继续运行
		if (WAIT_TIMEOUT == WaitForSingleObject(m_handle/*等待哪个线程，就填哪个线程的句柄*/, 1000/*等待的时间，单位是毫秒*/)) {
			//如果线程还在继续运行，就要强制杀死线程
			TerminateThread(m_handle, -1);
		}
		//关闭句柄
		CloseHandle(m_handle);
		m_handle = nullptr;
	}

	//2、关闭套接字
	if (!m_sock && INVALID_SOCKET != m_sock) {
		closesocket(m_sock);
	}
	//3、卸载库
	WSACleanup();
}